#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

const RENDERER_DIR = path.join(__dirname, '..', 'tekton-pipeline-renderer');
const VSCODE_DIR = path.join(__dirname, '..', 'tekton-vscode');

console.log('üîÑ Propagating changes from tekton-pipeline-renderer to tekton-vscode...');

/**
 * Update the VSCode extension's dependency on the renderer package
 */
function updateVSCodeDependency() {
  console.log('üì¶ Updating VSCode extension dependency...');
  
  const vscodePackagePath = path.join(VSCODE_DIR, 'package.json');
  const rendererPackagePath = path.join(RENDERER_DIR, 'package.json');
  
  if (!fs.existsSync(vscodePackagePath) || !fs.existsSync(rendererPackagePath)) {
    throw new Error('Package.json files not found');
  }
  
  const vscodePackage = JSON.parse(fs.readFileSync(vscodePackagePath, 'utf8'));
  const rendererPackage = JSON.parse(fs.readFileSync(rendererPackagePath, 'utf8'));
  
  // Update the workspace dependency reference
  const rendererName = rendererPackage.name;
  if (vscodePackage.dependencies && vscodePackage.dependencies[rendererName]) {
    vscodePackage.dependencies[rendererName] = `file:../tekton-pipeline-renderer`;
    console.log(`‚úÖ Updated ${rendererName} dependency to use workspace format`);
  }
  
  // Sync version numbers
  if (rendererPackage.version !== vscodePackage.version) {
    console.log(`üîÑ Syncing version: ${vscodePackage.version} -> ${rendererPackage.version}`);
    vscodePackage.version = rendererPackage.version;
  }
  
  fs.writeFileSync(vscodePackagePath, JSON.stringify(vscodePackage, null, 2) + '\n');
}

/**
 * Copy shared sample files if they exist
 */
function syncSampleFiles() {
  console.log('üìÅ Syncing sample files...');
  
  const rendererSamplesDir = path.join(RENDERER_DIR, 'samples');
  const vscodeSamplesDir = path.join(VSCODE_DIR, 'samples');
  
  if (fs.existsSync(rendererSamplesDir)) {
    if (!fs.existsSync(vscodeSamplesDir)) {
      fs.mkdirSync(vscodeSamplesDir, { recursive: true });
    }
    
    const sampleFiles = fs.readdirSync(rendererSamplesDir);
    sampleFiles.forEach(file => {
      const srcPath = path.join(rendererSamplesDir, file);
      const destPath = path.join(vscodeSamplesDir, file);
      
      if (fs.statSync(srcPath).isFile()) {
        fs.copyFileSync(srcPath, destPath);
        console.log(`‚úÖ Copied sample: ${file}`);
      }
    });
  }
}

/**
 * Bundle the renderer package directly into VSCode extension
 */
function bundleRendererCode() {
  console.log('üì¶ Bundling renderer code into VSCode extension...');
  
  const rendererSrcDir = path.join(RENDERER_DIR, 'src');
  const vscodeLibDir = path.join(VSCODE_DIR, 'src', 'lib', 'tekton-renderer');
  
  // Remove existing bundled code
  if (fs.existsSync(vscodeLibDir)) {
    execSync(`rm -rf "${vscodeLibDir}"`, { stdio: 'pipe' });
  }
  
  // Create lib directory
  fs.mkdirSync(vscodeLibDir, { recursive: true });
  
  // Copy renderer source code (excluding extension-specific files)
  const filesToCopy = [
    'components',
    'factories',
    'hooks', 
    'types',
    'utils',
    'index.ts'
  ];
  
  filesToCopy.forEach(item => {
    const srcPath = path.join(rendererSrcDir, item);
    const destPath = path.join(vscodeLibDir, item);
    
    if (fs.existsSync(srcPath)) {
      if (fs.statSync(srcPath).isDirectory()) {
        execSync(`cp -r "${srcPath}" "${destPath}"`, { stdio: 'pipe' });
      } else {
        execSync(`cp "${srcPath}" "${destPath}"`, { stdio: 'pipe' });
      }
      console.log(`‚úÖ Bundled: ${item}`);
    }
  });
  
  // Create a bundled index file
  const bundledIndexContent = `
// Auto-generated bundled export from tekton-pipeline-renderer
// DO NOT EDIT - This file is generated by the propagate script

export * from './components';
export * from './hooks';
export * from './types';
export * from './utils';
`;
  
  fs.writeFileSync(path.join(vscodeLibDir, 'index.ts'), bundledIndexContent);
  console.log('‚úÖ Created bundled index file');
}

/**
 * Update VSCode extension to use bundled code instead of external dependency
 */
function updateToBundledImports() {
  console.log('üîÑ Updating VSCode extension to use bundled imports...');
  
  const vscodePackagePath = path.join(VSCODE_DIR, 'package.json');
  const vscodePackage = JSON.parse(fs.readFileSync(vscodePackagePath, 'utf8'));
  
  // Remove the external dependency since we're bundling
  if (vscodePackage.dependencies && vscodePackage.dependencies['tekton-pipeline-renderer']) {
    delete vscodePackage.dependencies['tekton-pipeline-renderer'];
    console.log('‚úÖ Removed external renderer dependency');
  }
  
  fs.writeFileSync(vscodePackagePath, JSON.stringify(vscodePackage, null, 2) + '\n');
}

/**
 * Run post-propagation checks
 */
function runChecks() {
  console.log('üîç Running post-propagation checks...');
  
  try {
    // Check if the VSCode extension can resolve dependencies
    process.chdir(VSCODE_DIR);
    execSync('yarn install --check-files', { stdio: 'pipe' });
    console.log('‚úÖ VSCode extension dependencies are valid');
    
    // Check TypeScript compilation
    execSync('yarn run build', { stdio: 'pipe' });
    console.log('‚úÖ VSCode extension builds successfully with bundled code');
    
  } catch (error) {
    console.error('‚ùå Post-propagation checks failed:', error.message);
    process.exit(1);
  }
}

/**
 * Main execution
 */
function main() {
  try {
    // Always use bundled approach - copy files for self-contained extension
    console.log('üöÄ Using COPY propagation mode (self-contained extension)');
    bundleRendererCode();
    updateToBundledImports();
    syncSampleFiles();
    runChecks();
    
    console.log('‚úÖ Successfully propagated changes to VSCode extension');
    console.log('üí° Next steps: Run "npm run test" to verify everything works');
    
  } catch (error) {
    console.error('‚ùå Failed to propagate changes:', error.message);
    process.exit(1);
  }
}

if (require.main === module) {
  main();
}

module.exports = {
  updateVSCodeDependency,
  syncSampleFiles,
  bundleRendererCode,
  updateToBundledImports,
  runChecks
}; 